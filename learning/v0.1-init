# ğŸªœ First Step - TCP Banking Project in Rust

## ğŸ¯ Goal of the Commit

Set up the basic structure of a TCP-based banking system in Rust that can:
- Start either a **server** or a **client** based on CLI arguments.
- Allow a client to send text-based commands to the server.
- Let the server receive and print the commands (to be interpreted later).

---

## ğŸ“ Project Structure (initial)
```
banking_project/
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs              # Entry point, starts server or client based on args
â”‚   â”œâ”€â”€ lib.rs               # Optionally expose modules if you want reusability
â”‚
â”‚   â”œâ”€â”€ server.rs            # TCP server logic, handles client connections
â”‚   â”œâ”€â”€ client.rs            # TCP client logic, interacts with server
â”‚
â”‚   â”œâ”€â”€ bank.rs              # Central bank logic: account registry, transactions
â”‚   â”œâ”€â”€ account.rs           # Account struct and methods (deposit, withdraw, etc.)
â”‚   â”œâ”€â”€ commands.rs          # Command parser and dispatcher
â”‚   â”œâ”€â”€ utils.rs             # Shared utility functions (e.g. input handling)
â”‚
â”‚   â””â”€â”€ net/
â”‚       â”œâ”€â”€ handler.rs       # Connection handler: parses TCP input & responds
â”‚       â””â”€â”€ protocol.rs      # Defines the message format, parsing, validation
â”‚
â”œâ”€â”€ README.md
â””â”€â”€ tests/
    â”œâ”€â”€ integration.rs       # Integration tests for client-server interactions
```
---

## ğŸ”§ `main.rs`

**Functionality**:
- Collects command-line arguments via `env::args()`.
- Switches logic based on whether the user typed `"server"` or `"client"`.
- Delegates control to `start_server()` or `start_client()` accordingly.

**Struggle**:
- Misused the argument index at first (`args[0]` is always the binary name).
- Correct index for the first meaningful argument is `args[1]`.

---

## ğŸ–¥ï¸ `server.rs`

**Functionality**:
- Binds a `TcpListener` to `127.0.0.1:7878`.
- Waits in an infinite loop (`loop {}`) for client connections.
- Wraps the `TcpStream` into a `BufReader`.
- Reads client messages line by line using `.lines()`.

**Struggles**:
- Attempted to call `.accept()` on the `Result` instead of unwrapping it first.
- Confused use of `stream.read(...)` and `BufReader` (mixed incompatible APIs).
- Incorrectly wrote `stream.read(b"{}", f);` â€” wrong use of `read` and buffer.

**Fix**:
- Wrapped the stream using `BufReader::new(stream)`.
- Iterated over `lines()` properly, using `match` to handle errors.

---

## ğŸ“² `client.rs`

**Functionality**:
- Establishes a connection with the server at `127.0.0.1:7878`.
- Sends a hardcoded command (e.g., `"BALANCE 123\n"`) using `write_all(...)`.

**Struggles**:
- Minor confusion around writing bytes vs strings.
- Used raw bytes `b"..."` instead of converting a `String`.

---

## ğŸ§  Lessons Learned

- TCP communication in Rust is **low-level** but clear with `std::net`.
- `env::args()` returns all arguments including the binary path.
- Always unwrap/bind Result types before calling methods on the inner value.
- `BufReader` is ideal for handling line-based protocols.

---

## âœ… Next Steps

- Add a `handler.rs` to parse and process commands like `BALANCE`, `DEPOSIT`, etc.
- Implement actual account logic and shared state across clients.
- Make server respond back to client using `write()`.

---

**Commit Title**: `first step`

**Tagline**: Initialized TCP client/server logic and command routing based on args, with simple message sending and buffered reading.
